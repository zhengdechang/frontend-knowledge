---
title: ahooks API介绍与使用四
date: 2023-09-23 14:54:41
permalink: /pages/9d1d55/
categories:
  - frontend
  - ahooks
---
## 61. useEventTarget

`useEventTarget` 是一个用于创建并管理事件目标的 Hook。

```js
import { useEventTarget } from "ahooks";

function App() {
  const [value, { reset, onChange }] = useEventTarget();

  return (
    <div>
      <input value={value} onChange={onChange} />
      <button onClick={reset}>Reset</button>
    </div>
  );
}
```

在上述代码中，`useEventTarget`返回一个数组，第一个元素是当前的值，第二个元素是一个包含 `reset` 和 `onChange` 方法的对象。`onChange` 方法用于处理输入变化，`reset` 方法用于重置值。

## 62. useExternal

`useExternal` 是一个用于动态加载外部脚本或样式的 Hook。

```js
import { useExternal } from "ahooks";

function App() {
  const status = useExternal(
    "https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.27.0/moment.min.js"
  );

  return (
    <div>
      <p>{status}</p>
    </div>
  );
}
```

在上述代码中，`useExternal`接收一个外部资源的 URL 作为参数，并返回加载状态。

## 63. useFavicon

`useFavicon` 是一个用于动态更改网页图标的 Hook。

```js
import { useFavicon } from "ahooks";

function App() {
  useFavicon("/new-icon.ico");

  return (
    <div>
      <p>Check the favicon!</p>
    </div>
  );
}
```

在上述代码中，`useFavicon`接收一个新的 favicon 的 URL 作为参数。

## 64. useMutationObserver

`useMutationObserver` 是一个用于监听 DOM 变化的 Hook。

```js
import { useMutationObserver } from "ahooks";

function App() {
  const ref = useRef();
  useMutationObserver(ref, (mutations) => {
    // handle mutations
  });

  return (
    <div ref={ref}>
      <p>Content</p>
    </div>
  );
}
```

在上述代码中，`useMutationObserver`接收一个 `ref` 和一个处理函数。当 `ref` 所引用的 DOM 元素发生变化时，处理函数将被调用。

## 65. useLongPress

`useLongPress` 是一个用于处理长按事件的 Hook。

```js
import { useLongPress } from "ahooks";

function App() {
  const longPressEvents = useLongPress(() => {
    console.log("Long press activated");
  });

  return <button {...longPressEvents}>Long Press Me</button>;
}
```

在上述代码中，`useLongPress`接收一个处理函数，返回一个可以绑定到元素上的事件处理器对象。

## 66. useScroll

`useScroll` 是一个用于获取滚动位置的 Hook。

```js
import { useScroll } from "ahooks";

function App() {
  const position = useScroll();

  return (
    <div>
      <p>
        Scroll position: {position.top}, {position.left}
      </p>
    </div>
  );
}
```

在上述代码中，`useScroll`返回一个包含 `top` 和 `left` 属性的对象，表示滚动位置。

## 67. useResponsive

`useResponsive` 是一个用于响应式编程的 Hook。

```js
import { useResponsive } from "ahooks";

function App() {
  const screen = useResponsive();

  return (
    <div>
      <p>Current screen: {screen.isDesktop ? "Desktop" : "Mobile"}</p>
    </div>
  );
}
```

在上述代码中，`useResponsive`返回一个对象，该对象包含了一些布尔值属性，如 `isDesktop` 和 `isMobile`，表示当前屏幕类型。

## 68. useFocusWithin

`useFocusWithin` 是一个用于处理元素内部焦点状态的 Hook。

```js
import { useFocusWithin } from "ahooks";

function App() {
  const { isFocusWithin } = useFocusWithin();

  return (
    <div>
      <input />
      <p>{isFocusWithin ? "Focused" : "Not Focused"}</p>
    </div>
  );
}
```

在上述代码中，`useFocusWithin`返回一个对象，该对象包含一个 `isFocusWithin` 属性，表示元素内部是否有焦点。

## 69. useControllableValue

`useControllableValue` 是一个用于处理可控制值的 Hook。

```js
import { useControllableValue } from "ahooks";

function App() {
  const [value, setValue] = useControllableValue();

  return (
    <div>
      <input value={value} onChange={(e) => setValue(e.target.value)} />
    </div>
  );
}
```

在上述代码中，`useControllableValue`返回一个数组，第一个元素是当前的值，第二个元素是一个用于设置该值的函数。

## 70. useEventEmitter

`useEventEmitter` 是一个用于创建事件发射器的 Hook。

```js
import { useEventEmitter } from "ahooks";

function App() {
  const emitter = useEventEmitter();

  useEffect(() => {
    emitter.on("message", (msg) => {
      console.log(msg);
    });

    emitter.emit("message", "Hello");
  }, []);

  return (
    <div>
      <p>Check the console!</p>
    </div>
  );
}
```

在上述代码中，`useEventEmitter`返回一个事件发射器对象，你可以在其上注册事件并发出事件。

## 71. useIsomorphicLayoutEffect

`useIsomorphicLayoutEffect` 是一个在服务器端和客户端都可以用的 `useLayoutEffect`。在服务器端渲染（SSR）中，React 会警告你不应该使用 `useLayoutEffect`，因为它没有意义。在这种情况下，你可以使用 `useIsomorphicLayoutEffect`。

```js
import { useIsomorphicLayoutEffect } from "ahooks";

function App() {
  useIsomorphicLayoutEffect(() => {
    console.log(
      "This will run on both server and client side without warnings"
    );
  }, []);

  return <div>Hello World</div>;
}
```

在上述代码中，`useIsomorphicLayoutEffect` 接收两个参数，和 `useEffect` 或 `useLayoutEffect` 一样。第一个参数是要运行的函数，第二个参数是依赖数组。当依赖数组的值改变时，函数会重新运行。

## 72. useLatest

`useLatest` 是用于获取最新的 ref 值的 Hook。它总是返回传递给它的值的最新版本。

```js
import { useLatest } from "ahooks";

function App() {
  const [count, setCount] = useState(0);
  const latestCount = useLatest(count);

  useEffect(() => {
    setTimeout(() => {
      console.log(latestCount.current); // Always logs the latest count
    }, 3000);
  }, []);

  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

在上述代码中，`useLatest` 接收一个参数，并返回一个 ref 对象，该对象的 `current` 属性总是等于最新的值。

## 73. useMemoizedFn

`useMemoizedFn` 是一个用于创建记忆化函数的 Hook。它返回一个函数，该函数的身份在每次渲染时都保持不变，只有当依赖项更改时，才会创建一个新的函数。

```js
import { useMemoizedFn } from "ahooks";

function App() {
  const [count, setCount] = useState(0);

  const increment = useMemoizedFn(() => {
    setCount(count + 1);
  }, [count]);

  return (
    <div>
      <p>{count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

在上述代码中，`useMemoizedFn` 接收两个参数。第一个参数是要记忆化的函数，第二个参数是依赖项数组。当依赖项更改时，将创建一个新的函数。

## 74. useReactive

`useReactive` 是一个用于创建响应式对象的 Hook。它返回一个新的对象，当对象的属性更改时，组件将重新渲染。

```js
import { useReactive } from "ahooks";

function App() {
  const state = useReactive({ count: 0 });

  return (
    <div>
      <p>{state.count}</p>
      <button onClick={() => state.count++}>Increment</button>
    </div>
  );
}
```

在上述代码中，`useReactive` 接收一个对象并返回一个新的响应式对象。当响应式对象的属性更改时，组件将重新渲染。

## 75. useTrackedEffect

`useTrackedEffect` 是一个用于跟踪 effect 的 Hook。它允许你知道 effect 何时运行，何时清理，以及何时重新运行。

```js
import { useTrackedEffect } from "ahooks";

function App() {
  const [count, setCount] = useState(0);

  useTrackedEffect(
    (track) => {
      track(() => {
        console.log("Effect is running");
      });

      return () => {
        console.log("Effect is cleaning up");
      };
    },
    [count]
  );

  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

在上述代码中，`useTrackedEffect` 接收两个参数。第一个参数是一个函数，它接收一个 `track` 函数作为参数。你可以在 effect 中使用 `track` 函数来标记你想要跟踪的部分。第二个参数是依赖项数组。当依赖项更改时，effect 将重新运行，并首先执行清理函数。
