---
title: ahooks API介绍与使用三
date: 2023-09-23 14:54:42
permalink: /pages/ef2a7c/
categories:
  - frontend
  - ahooks
---
## 41. useAsyncEffect

`useAsyncEffect` 是一个用于处理异步操作的 Hook，它可以在 effect 中使用 async/await。

```js
import { useAsyncEffect } from "ahooks";

function App() {
  useAsyncEffect(async () => {
    const data = await fetchData();
    console.log(data);
  }, []);

  return <div>...</div>;
}
```

上述代码中，`useAsyncEffect`接收一个异步函数和依赖数组作为参数。异步函数会在组件挂载后和依赖项改变后执行。

## 42. useDebounceEffect

`useDebounceEffect` 是一个在依赖项改变后延迟执行副作用的 Hook。

```js
import { useDebounceEffect } from "ahooks";

function App() {
  const [value, setValue] = useState("");

  useDebounceEffect(
    () => {
      console.log(value);
    },
    [value],
    500
  );

  return <input value={value} onChange={(e) => setValue(e.target.value)} />;
}
```

上述代码中，`useDebounceEffect`接收一个函数，依赖数组和延迟时间作为参数。函数会在依赖项改变后的指定延迟时间后执行。

## 43. useDebounceFn

`useDebounceFn` 是一个用于延迟函数执行的 Hook。

```js
import { useDebounceFn } from "ahooks";

function App() {
  const { run } = useDebounceFn(() => {
    console.log("Hello");
  }, 500);

  return <button onClick={run}>Say Hello</button>;
}
```

上述代码中，`useDebounceFn`接收一个函数和延迟时间作为参数，返回一个对象，该对象包含一个`run`方法，当调用这个方法时，会在指定延迟时间后执行传入的函数。

## 44. useThrottleFn

`useThrottleFn` 是一个用于节流函数执行的 Hook。

```js
import { useThrottleFn } from "ahooks";

function App() {
  const { run } = useThrottleFn(() => {
    console.log("Hello");
  }, 500);

  return <button onClick={run}>Say Hello</button>;
}
```

上述代码中，`useThrottleFn`接收一个函数和延迟时间作为参数，返回一个对象，该对象包含一个`run`方法，当调用这个方法时，会以节流的方式执行传入的函数。

## 45. useThrottleEffect

`useThrottleEffect` 是一个在依赖项改变后以节流方式执行副作用的 Hook。

```js
import { useThrottleEffect } from "ahooks";

function App() {
  const [value, setValue] = useState("");

  useThrottleEffect(
    () => {
      console.log(value);
    },
    [value],
    500
  );

  return <input value={value} onChange={(e) => setValue(e.target.value)} />;
}
```

上述代码中，`useThrottleEffect`接收一个函数，依赖数组和延迟时间作为参数。函数会在依赖项改变后以节流的方式执行。

## 46. useDeepCompareEffect

`useDeepCompareEffect` 是一个用于深度比较依赖项的 Hook，只有当依赖项深度比较改变时，才会执行副作用。

```js
import { useDeepCompareEffect } from "ahooks";

function App() {
  const [value, setValue] = useState({ key: "value" });

  useDeepCompareEffect(() => {
    console.log(value);
  }, [value]);

  return <div>...</div>;
}
```

上述代码中，`useDeepCompareEffect`接收一个函数和依赖数组作为参数。函数只有在依赖项深度比较改变时才会执行。

## 47. usePrevious

`usePrevious` 是一个用于获取上一个状态或属性的 Hook。

```js
import { usePrevious } from "ahooks";

function App() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);

  return (
    <div>
      <p>
        Now: {count}, before: {prevCount}
      </p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

上述代码中，`usePrevious`接收当前状态或属性作为参数，返回该状态或属性的上一个值。

## 48. useRafState

`useRafState` 是一个用于在下一个动画帧中更新状态的 Hook。

```js
import { useRafState } from "ahooks";

function App() {
  const [count, setCount] = useRafState(0);

  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

上述代码中，`useRafState`接收初始状态作为参数，返回当前状态和一个设置函数。设置函数会在下一个动画帧中更新状态。

## 49. useSafeState

`useSafeState` 是一个安全的状态 Hook，它可以确保在组件卸载后不会设置状态。

```js
import { useSafeState } from "ahooks";

function App() {
  const [count, setCount] = useSafeState(0);

  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

上述代码中，`useSafeState`接收初始状态作为参数，返回当前状态和一个设置函数。设置函数会确保在组件卸载后不会设置状态。

## 50. useGetState

`useGetState` 是一个用于获取当前状态的 Hook，无论何时调用，都会返回最新的状态。

```js
import { useGetState } from "ahooks";

function App() {
  const [count, setCount, getState] = useGetState(0);

  const handleDouble = () => {
    setCount(getState() * 2);
  };

  return (
    <div>
      <p>{count}</p>
      <button onClick={handleDouble}>Double</button>
    </div>
  );
}
```

上述代码中，`useGetState`接收初始状态作为参数，返回当前状态，一个设置函数，和一个获取当前状态的函数。无论何时调用获取状态的函数，都会返回最新的状态。

## 51. useResetState

useResetState 是一个用于重置状态的 Hook。

```js
import { useResetState } from "ahooks";

function App() {
  const [value, setValue, resetValue] = useResetState("default");

  return (
    <div>
      <p>{value}</p>
      <button onClick={() => setValue("New Value")}>Change Value</button>
      <button onClick={resetValue}>Reset</button>
    </div>
  );
}
```

在上面的代码中，useResetState 接收一个参数作为默认值。这个 Hook 返回一个数组，第一个元素是当前的值，第二个元素是一个设置该值的函数，第三个元素是一个重置值到默认值的函数。

## 52. useUpdateLayoutEffect

useUpdateLayoutEffect 是一个在组件更新时运行的 Hook，它与 useEffect 类似，但它的执行时机更早，会在浏览器执行绘制之前进行。

```js
import { useUpdateLayoutEffect } from "ahooks";

function App() {
  const [count, setCount] = useState(0);

  useUpdateLayoutEffect(() => {
    console.log("count", count);
  }, [count]);

  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>Increase</button>
    </div>
  );
}
```

在上面的代码中，useUpdateLayoutEffect 接收两个参数，第一个是一个函数，这个函数将在组件更新时执行，第二个参数是一个依赖项数组。

## 53. useDeepCompareLayoutEffect

useDeepCompareLayoutEffect 类似于 useLayoutEffect，但它可以进行深度比较的依赖项。

```js
import { useDeepCompareLayoutEffect } from "ahooks";

function App() {
  const [state, setState] = useState({ count: 0 });

  useDeepCompareLayoutEffect(() => {
    console.log("state", state);
  }, [state]);

  return (
    <div>
      <button onClick={() => setState((s) => ({ count: s.count + 1 }))}>
        Increase
      </button>
    </div>
  );
}
```

在上面的代码中，useDeepCompareLayoutEffect 接收两个参数，第一个是一个函数，这个函数将在依赖项发生深度变化时执行，第二个参数是一个依赖项数组。

## 54. useRafInterval

useRafInterval 是一个使用 requestAnimationFrame 实现的 setInterval，它可以在每个浏览器重绘之前执行一次。

```js
import { useRafInterval } from "ahooks";

function App() {
  const [count, setCount] = useState(0);

  useRafInterval(() => {
    setCount((c) => c + 1);
  }, 1000);

  return <div>{count}</div>;
}
```

在上面的代码中，useRafInterval 接收两个参数，第一个是一个函数，这个函数将在设定的时间间隔内执行，第二个参数是时间间隔（毫秒）。

## 55. useRafTimeout

useRafTimeout 是一个使用 requestAnimationFrame 实现的 setTimeout，它可以在指定的时间后执行一次。

```js
import { useRafTimeout } from "ahooks";

function App() {
  const { run } = useRafTimeout(() => alert("Hello"), 5000);

  useEffect(() => {
    run();
  }, []);

  return <div>Hello World</div>;
}
```

在上面的代码中，useRafTimeout 接收两个参数，第一个是一个函数，这个函数将在设定的时间后执行，第二个参数是延迟时间（毫秒）。

## 56. useTimeout

useTimeout 是一个用于设置延迟执行的 Hook。

```js
import { useTimeout } from "ahooks";

function App() {
  const { run } = useTimeout(() => alert("Hello"), 5000);

  useEffect(() => {
    run();
  }, []);

  return <div>Hello World</div>;
}
```

在上面的代码中，useTimeout 接收两个参数，第一个是一个函数，这个函数将在设定的时间后执行，第二个参数是延迟时间（毫秒）。

## 57. useLockFn

useLockFn 是一个用于锁定函数执行的 Hook，防止函数在异步操作期间被多次调用。

```js
import { useLockFn } from "ahooks";

function App() {
  const submit = useLockFn(async () => {
    await new Promise((resolve) => setTimeout(resolve, 1000));
    alert("Submit success");
  });

  return (
    <div>
      <button onClick={submit}>Submit</button>
    </div>
  );
}
```

在上面的代码中，useLockFn 接收一个异步函数作为参数，返回一个新的函数，这个新的函数在上一个异步操作完成之前不会被执行。

## 58. useDocumentVisibility

useDocumentVisibility 是一个用于获取文档可见状态的 Hook。

```js
import { useDocumentVisibility } from "ahooks";

function App() {
  const visibility = useDocumentVisibility();

  return <div>Document is {visibility}</div>;
}
```

在上面的代码中，useDocumentVisibility 不接收任何参数，它返回当前文档的可见状态，如 'visible'，'hidden' 或 'prerender'。

## 59. useDrop

useDrop 是一个用于实现拖放功能的 Hook。

```js
import { useDrop } from "ahooks";

function App() {
  const [props, { isHovering }] = useDrop({
    onText: (text, e) => {
      console.log("You dropped text: ", text);
    },
  });

  return (
    <div {...props}>{isHovering ? "Release to drop" : "Drag file to here"}</div>
  );
}
```

在上面的代码中，useDrop 接收一个对象作为参数，这个对象包含一些回调函数，这些函数将在拖放事件发生时被调用。它返回一个数组，第一个元素是用于绑定到 DOM 元素的属性，第二个元素是一个对象，包含了一些状态值。

## 60. useDrag

useDrag 是一个用于实现拖动功能的 Hook。

```js
import { useDrag } from "ahooks";

function App() {
  const [props, { isDragging }] = useDrag();

  return <div {...props}>{isDragging ? "Now dragging" : "Drag me"}</div>;
}
```

在上面的代码中，useDrag 不接收任何参数，它返回一个数组，第一个元素是用于绑定到 DOM 元素的属性，第二个元素是一个对象，包含了一些状态值。
